<!-- index.html - גלריה תלת-ממדית סייבר עם HUD משודרג כולל שעון -->
<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>גלריה תלת-ממדית סייבר דינמית</title>
  <style>
    /* בסיס ורספונסיביות */
    html, body { margin:0; padding:0; width:100%; height:100%; overflow:hidden; background:#000; touch-action:none; }
    canvas { display:block; width:100%; height:100%; }

   /* HUD וגילוי/הסתרה */
    #hudTab {
      position:absolute; top:8px; right:8px;
      width:32px; height:32px;
      background:rgba(0,0,0,0.6); border:2px solid #0f0;
      border-radius:4px 0 0 4px; z-index:101;
      display:flex; align-items:center; justify-content:center;
      cursor:pointer;
    }
    #hudTab .icon { color:#0f0; font-size:20px; text-shadow:0 0 5px #0f0; }

    #hud {
      position:absolute; top:8px; right:40px;
      width:calc(100% - 56px); max-width:320px; max-height:calc(100vh - 16px); overflow-y:auto; /* max-height calc */
      background:rgba(0,0,0,0.6); border:2px solid #0f0; border-radius:8px;
      padding:8px; box-sizing:border-box;
      font-family:monospace; font-size:14px; color:#0f0; z-index:100;
    }
    #hud.hidden { display:none; }
    #hud label { display:flex; align-items:center; margin:6px 0; }
    #hud label .icon { margin-left:6px; color:#0f0; text-shadow:0 0 5px #0f0; }
    #hud label span { flex:1; }
    #hud input[type=range] {
      -webkit-appearance:none; width:100%; height:8px; border-radius:4px;
      background:linear-gradient(to right, #0f0 0%, #f00 100%);
      outline:none; margin-top:4px;
    }
    #hud input[type=range]::-webkit-slider-thumb {
      -webkit-appearance:none; width:16px; height:16px; border-radius:50%; background:#0f0; cursor:pointer; border:2px solid #000;
    }
    #hud input[type=range]::-moz-range-thumb {
      width:16px; height:16px; border-radius:50%; background:#0f0; cursor:pointer; border:2px solid #000;
    }
    #hud input[type="file"] {
        color: #0f0;
        background-color: rgba(0,255,0,0.1);
        border: 1px solid #0f0;
        padding: 3px;
        margin-top: 4px;
        font-size: 12px;
        width: 100%;
    }
    #hud input[type="file"]::file-selector-button {
        background-color: #0f0;
        color: #000;
        border: none;
        padding: 2px 6px;
        border-radius: 2px;
        cursor: pointer;
    }


    /* שעון ותאריך */
    #clock {
      text-align:center; margin:8px 0;
      font-family:monospace; font-size:16px; color:#ff0;
      text-shadow:0 0 8px #ff0;
    }

    /* מודאל */
    .modal { position:fixed; top:0; left:0; width:100%; height:100%; display:flex;
      align-items:center; justify-content:center;
      background:rgba(0,0,0,0.9); visibility:hidden; opacity:0; transition:opacity .4s; z-index:1050; /* Increased z-index */
    }
    .modal.visible { visibility:visible; opacity:1; }
    .modal img {
      max-width:90%; max-height:90%; border-radius:8px;
      transform:scale(0.7); opacity:0;
      transition:transform .4s ease, opacity .4s ease;
      box-shadow:0 0 20px #0f0, 0 0 40px #0f0; /* Enhanced shadow */
    }
    .modal.visible img { transform:scale(1); opacity:1; }

    /* טקסטים סייבר */
    .cyber-text { position:absolute; color:#0f0; font-family:'Courier New',monospace; font-size:16px;
      pointer-events:none; animation:flicker 2s infinite; opacity:0.6; /* Removed var(--blinkSpeed) for CSS animation */
    }
    @keyframes flicker { 0%,100%{opacity:0.2;} 50%{opacity:0.8;} }
  </style>
</head>
<body>
  <!-- לחצן HUD עם אייקון סייבר -->
  <div id="hudTab"><span class="icon">⚙</span></div>
  <!-- HUD -->
  <div id="hud" class="hidden"> <!-- Start hidden by default -->
    <div id="clock"></div>
    <label><span class="icon">📁</span><span>Files: <span id="fileCount">0</span></span><input id="fileInputHud" type="file" accept="image/*" multiple></label>
    <label><span class="icon">🔄</span><span>מהירות סיבוב <span id="rotateVal">0.0006</span></span><input id="rotateSlider" type="range" min="0" max="0.02" step="0.0001" value="0.0006"></label>
    <label><span class="icon">✨</span><span>מהירות כוכבים <span id="starVal">0.0034</span></span><input id="starSlider" type="range" min="0" max="0.01" step="0.0001" value="0.0034"></label>
    <label><span class="icon">⚡</span><span>מהירות הבהוב <span id="blinkVal">0.02</span></span><input id="blinkSlider" type="range" min="0" max="0.05" step="0.001" value="0.02"></label>
    <label><span class="icon">🔍</span><span>גודל גלובלי <span id="scaleVal">0.5</span></span><input id="scaleSlider" type="range" min="0.1" max="2" step="0.1" value="0.5"></label>
    <label><span class="icon">📐</span><span>עובי מסגרות <span id="frameWidthVal">8</span></span><input id="frameWidthSlider" type="range" min="1" max="12" step="1" value="8"></label>
    <label><span class="icon">☁️</span><span>שקיפות מסגרות <span id="frameOpacityVal">1</span></span><input id="frameOpacitySlider" type="range" min="0" max="1" step="0.1" value="1"></label>
    <label><span class="icon">⭐</span><span>גודל כוכבים <span id="starSizeVal">4</span></span><input id="starSizeSlider" type="range" min="0.5" max="8" step="0.5" value="4"></label>
    <label><span class="icon">🌌</span><span>מספר כוכבים <span id="starCountVal">2000</span></span><input id="starCountSlider" type="range" min="100" max="3000" step="100" value="2000"></label>
    <label><span class="icon">🌠</span><span>שקיפות תמונות <span id="imgOpacityVal">1</span></span><input id="imgOpacitySlider" type="range" min="0" max="1" step="0.1" value="1"></label>
  </div>

  <div id="modal" class="modal"><img id="modalImg" src=""></div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.134.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.134.0/examples/js/controls/OrbitControls.js"></script>
  <script>
    const params = new URLSearchParams(window.location.search);

    // --- Get values from URL or use defaults ---
    let autoRotateSpeed = parseFloat(params.get('autoRotateSpeed')) || 0.0006;
    let starRotSpeed = parseFloat(params.get('starRotSpeed')) || 0.0034;
    let blinkSpeed = parseFloat(params.get('blinkSpeed')) || 0.02; // This will be used by JS, not directly by CSS animation
    let globalScale = parseFloat(params.get('globalScale')) || 0.5;
    let frameWidth = parseInt(params.get('frameWidth'), 10) || 8;
    let frameOpacity = parseFloat(params.get('frameOpacity')) || 1;
    let starSize = parseFloat(params.get('starSize')) || 4;
    let starCount = parseInt(params.get('starCount'), 10) || 2000;
    let imgOpacity = parseFloat(params.get('imgOpacity')) || 1;

    // Other params from your original code
    const requestId = params.get('reqId');
    const currentTheme = params.get('theme');
    const offlineMode = params.get('offline') === 'true';
    // Note: initialImages from URL is not directly handled here yet, would need more complex parsing if passed.
    // This script will use defaultImages or images from fileInputHud.

    const maxImages = 333;
    let imageItems = []; 
    
    const defaultImages = [];
    for(let i = 1; i <= 110; i++) defaultImages.push({url: `https://picsum.photos/seed/${i}/400/300`, name: `Image${i}`});

    if (imageItems.length === 0) { // Initialize with defaults if not populated by other means (e.g., future URL param for images)
        imageItems = [...defaultImages];
    }

    // DOM Elements
    const hud = document.getElementById('hud');
    const hudTab = document.getElementById('hudTab');
    const clockDiv = document.getElementById('clock');
    const fileCountSpan = document.getElementById('fileCount');
    const fileInputHud = document.getElementById('fileInputHud');
    
    const rotateSlider = document.getElementById('rotateSlider');
    const rotateValSpan = document.getElementById('rotateVal');
    const starSlider = document.getElementById('starSlider');
    const starValSpan = document.getElementById('starVal');
    const blinkSlider = document.getElementById('blinkSlider');
    const blinkValSpan = document.getElementById('blinkVal');
    const scaleSlider = document.getElementById('scaleSlider');
    const scaleValSpan = document.getElementById('scaleVal');
    const frameWidthSlider = document.getElementById('frameWidthSlider');
    const frameWidthValSpan = document.getElementById('frameWidthVal');
    const frameOpacitySlider = document.getElementById('frameOpacitySlider');
    const frameOpacityValSpan = document.getElementById('frameOpacityVal');
    const starSizeSlider = document.getElementById('starSizeSlider');
    const starSizeValSpan = document.getElementById('starSizeVal');
    const starCountSlider = document.getElementById('starCountSlider');
    const starCountValSpan = document.getElementById('starCountVal');
    const imgOpacitySlider = document.getElementById('imgOpacitySlider');
    const imgOpacityValSpan = document.getElementById('imgOpacityVal');

    const modal = document.getElementById('modal');
    const modalImg = document.getElementById('modalImg');

    // Three.js setup
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(60, innerWidth / innerHeight, 0.1, 2000);
    camera.position.z = 350;
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(innerWidth, innerHeight);
    document.body.appendChild(renderer.domElement);
    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.autoRotate = false; // Controlled by autoRotateSpeed variable
    const raycaster = new THREE.Raycaster(), mouse = new THREE.Vector2();
    const group = new THREE.Group(), frames = [];
    let stars;

    // --- Initialize HUD with values (from URL or defaults) ---
    function initializeHudValues() {
        if (rotateSlider) rotateSlider.value = autoRotateSpeed;
        if (rotateValSpan) rotateValSpan.textContent = autoRotateSpeed.toFixed(4);
        if (starSlider) starSlider.value = starRotSpeed;
        if (starValSpan) starValSpan.textContent = starRotSpeed.toFixed(4);
        if (blinkSlider) blinkSlider.value = blinkSpeed;
        if (blinkValSpan) blinkValSpan.textContent = blinkSpeed.toFixed(3);
        if (scaleSlider) scaleSlider.value = globalScale;
        if (scaleValSpan) scaleValSpan.textContent = globalScale.toFixed(1);
        if (frameWidthSlider) frameWidthSlider.value = frameWidth;
        if (frameWidthValSpan) frameWidthValSpan.textContent = frameWidth;
        if (frameOpacitySlider) frameOpacitySlider.value = frameOpacity;
        if (frameOpacityValSpan) frameOpacityValSpan.textContent = frameOpacity.toFixed(1);
        if (starSizeSlider) starSizeSlider.value = starSize;
        if (starSizeValSpan) starSizeValSpan.textContent = starSize.toFixed(1);
        if (starCountSlider) starCountSlider.value = starCount;
        if (starCountValSpan) starCountValSpan.textContent = starCount;
        if (imgOpacitySlider) imgOpacitySlider.value = imgOpacity;
        if (imgOpacityValSpan) imgOpacityValSpan.textContent = imgOpacity.toFixed(1);
        if (fileCountSpan) fileCountSpan.textContent = imageItems.length;
    }


    if (requestId) {
      console.log('Request ID (from template):', requestId);
      document.title = `גלריה - בקשה ${requestId}`;
    }
    if (currentTheme) {
      console.log('Theme (from template):', currentTheme);
      document.body.classList.add(`theme-${currentTheme}`);
    }
    if (offlineMode) {
        console.log('Template is in offline mode.');
    }

    function updateClock() {
      const now = new Date();
      const date = now.toLocaleDateString('he-IL', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' });
      const time = now.toLocaleTimeString('he-IL');
      if (clockDiv) clockDiv.textContent = `${date} ${time}`;
    }
    setInterval(updateClock, 1000);
    updateClock();

    function buildScene() {
      group.clear(); // Clear previous objects from the group
      frames.length = 0; // Clear frames array
      if (stars) scene.remove(stars); // Remove previous stars

      const geom = new THREE.BufferGeometry(), pos = new Float32Array(starCount * 3);
      for (let i = 0; i < starCount; i++) {
        pos[i * 3] = (Math.random() - 0.5) * 2000;
        pos[i * 3 + 1] = (Math.random() - 0.5) * 2000;
        pos[i * 3 + 2] = (Math.random() - 0.5) * 2000;
      }
      geom.setAttribute('position', new THREE.BufferAttribute(pos, 3));
      stars = new THREE.Points(geom, new THREE.PointsMaterial({ color: 0xffffff, size: starSize, transparent: true, opacity: 1 }));
      scene.add(stars);
      
      if (imageItems.length === 0) {
        console.warn("No images to display in the globe.");
        return;
      }

      const baseSize = 60;
      const w = baseSize * globalScale, h = w * 0.75;
      const radius = 200, phiStep = Math.PI * (3 - Math.sqrt(5));

      imageItems.forEach((item, i) => {
        const y = 1 - (i / (imageItems.length - 1)) * 2;
        const rY = Math.sqrt(1 - y * y);
        const theta = phiStep * i;
        const x = Math.cos(theta) * radius * rY;
        const z = Math.sin(theta) * radius * rY;
        
        const planeGeo = new THREE.PlaneGeometry(w, h);
        let texture;
        try {
            texture = new THREE.TextureLoader().load(item.url, 
                () => {}, 
                undefined, 
                (err) => { console.error(`Error loading texture for ${item.url}:`, err); }
            );
        } catch (e) {
            console.error(`Failed to initiate texture loading for ${item.url}:`, e);
        }

        const mat = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide, transparent: true, opacity: imgOpacity });
        const mesh = new THREE.Mesh(planeGeo, mat);
        mesh.position.set(x, y * radius, z);
        mesh.lookAt(0, 0, 0);
        mesh.userData = { url: item.url };
        group.add(mesh);
        
        const edgeGeo = new THREE.EdgesGeometry(planeGeo);
        const edgeMat = new THREE.LineBasicMaterial({ color: 0x0f0, linewidth: frameWidth, transparent: true, opacity: frameOpacity });
        const frame = new THREE.LineSegments(edgeGeo, edgeMat);
        frame.position.copy(mesh.position);
        frame.rotation.copy(mesh.rotation);
        group.add(frame);
        frames.push(frame);
        
        const cvs = document.createElement('canvas');
        const contextScale = 2;
        cvs.width = 256 * contextScale; 
        cvs.height = 64 * contextScale;
        const ctx = cvs.getContext('2d'); 
        ctx.scale(contextScale, contextScale);
        ctx.font = 'bold 20px monospace'; // Changed font
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillStyle = '#00ff00'; // Green text
        ctx.shadowColor = '#00ff00';
        ctx.shadowBlur = 8; // Slightly less blur
        ctx.fillText(item.name || 'Untitled', 128, 32);
        
        const canvasTexture = new THREE.CanvasTexture(cvs);
        const spriteMat = new THREE.SpriteMaterial({ map: canvasTexture, transparent: true, depthTest: false });
        const sprite = new THREE.Sprite(spriteMat); 
        sprite.scale.set(w * 0.8, h * 0.2, 1); // Adjusted sprite scale
        const yOffset = h / 2 + (h * 0.1) + 5; // Position sprite slightly more below
        sprite.position.set(x, y * radius - yOffset, z); 
        sprite.renderOrder = 1;
        group.add(sprite);
      }); 
      scene.add(group); 
      createCyberTexts();
      if (fileCountSpan) fileCountSpan.textContent = imageItems.length;
    }

    if (hudTab) hudTab.addEventListener('click', () => { if (hud) hud.classList.toggle('hidden'); });

    function createCyberTexts() {
      document.querySelectorAll('.cyber-text').forEach(e => e.remove());
      const samples = ['01010101', 'H4CK3R', 'CY8ER', '▓▓▓▓', 'ᚠᛟᛋ', 'BO0T', 'C0D3', 'SYS', '███', 'NE0N', 'ACCESS', 'DATASTREAM', 'ENCRYPTED', 'SECURE', 'NODE', 'NETWORK'];
      samples.forEach((s, i) => {
        const el = document.createElement('div');
        el.className = 'cyber-text';
        el.textContent = s;
        el.style.top = Math.random() * 90 + '%';
        el.style.left = Math.random() * 90 + '%';
        el.style.setProperty('--blinkSpeed', (Math.random() * 1.5 + 0.5) + 's'); // Randomize blink speed slightly
        document.body.appendChild(el);
      });
      const fix = document.createElement('div');
      fix.className = 'cyber-text';
      fix.textContent = 'i24CyberSphere v3.1'; // Updated text
      fix.style.color = '#ff0'; // Yellow
      fix.style.top = '2%'; fix.style.left = '2%';
      fix.style.animation = 'none'; fix.style.opacity = '0.8';
      document.body.appendChild(fix);
    }

    function setupHUDListeners() {
      if (fileInputHud) {
        fileInputHud.addEventListener('change', e => {
          const files = Array.from(e.target.files).slice(0, maxImages - imageItems.length);
          if (files.length === 0) return;

          let loadedCount = 0;
          const newImages = [];
          files.forEach(f => {
              const r = new FileReader();
              r.onload = ev => {
                  newImages.push({ url: ev.target.result, name: f.name });
                  loadedCount++;
                  if (loadedCount === files.length) {
                      imageItems = [...imageItems, ...newImages].slice(0, maxImages);
                      if (fileCountSpan) fileCountSpan.textContent = imageItems.length;
                      buildScene();
                  }
              };
              r.onerror = (err) => {
                  console.error("Error reading file:", f.name, err);
                  loadedCount++;
                   if (loadedCount === files.length) {
                      imageItems = [...imageItems, ...newImages].slice(0, maxImages);
                      if (fileCountSpan) fileCountSpan.textContent = imageItems.length;
                      buildScene();
                  }
              };
              r.readAsDataURL(f);
          });
        });
      }

      const sliderMap = { 
        rotateSlider: { variable: 'autoRotateSpeed', span: rotateValSpan, precision: 4, updateFn: val => autoRotateSpeed = val },
        starSlider: { variable: 'starRotSpeed', span: starValSpan, precision: 4, updateFn: val => starRotSpeed = val },
        blinkSlider: { variable: 'blinkSpeed', span: blinkValSpan, precision: 3, updateFn: val => blinkSpeed = val },
        scaleSlider: { variable: 'globalScale', span: scaleValSpan, precision: 1, updateFn: val => { globalScale = val; buildScene(); } },
        frameWidthSlider: { variable: 'frameWidth', span: frameWidthValSpan, precision: 0, updateFn: val => { frameWidth = val; buildScene(); } },
        frameOpacitySlider: { variable: 'frameOpacity', span: frameOpacityValSpan, precision: 1, updateFn: val => { frameOpacity = val; buildScene(); /* might need specific update */ } },
        starSizeSlider: { variable: 'starSize', span: starSizeValSpan, precision: 1, updateFn: val => { starSize = val; if (stars) stars.material.size = val; } },
        starCountSlider: { variable: 'starCount', span: starCountValSpan, precision: 0, updateFn: val => { starCount = val; buildScene(); } },
        imgOpacitySlider: { variable: 'imgOpacity', span: imgOpacityValSpan, precision: 1, updateFn: val => { imgOpacity = val; buildScene(); /* might need specific update */ } }
      };

      Object.entries(sliderMap).forEach(([sliderId, config]) => {
        const sliderElement = document.getElementById(sliderId);
        if (sliderElement && config.span) {
          sliderElement.addEventListener('input', e => {
            const value = config.precision > 0 ? parseFloat(e.target.value) : parseInt(e.target.value, 10);
            config.updateFn(value);
            config.span.textContent = value.toFixed(config.precision);
          });
        }
      });
    }
    
    function animate() {
      requestAnimationFrame(animate);
      group.rotation.y += autoRotateSpeed;
      if (stars) stars.rotation.y += starRotSpeed;
      
      // Update frame opacity using JS for blinkSpeed control from variable
      frames.forEach((f, i) => {
          if(f.material) { // Ensure material exists
              f.material.opacity = frameOpacity + 0.3 * Math.sin(Date.now() * (blinkSpeed * 100) + i); // blinkSpeed might need scaling for desired effect
          }
      });

      controls.update();
      renderer.render(scene, camera);
    }    
    
    let lastClickTime = 0;
    const DOUBLE_CLICK_THRESHOLD = 300;

    window.addEventListener('click', e => {
        if (e.target.closest('#hud') || e.target.closest('#hudTab')) { // Ignore clicks on HUD
            return;
        }
        const currentTime = new Date().getTime();
        if (currentTime - lastClickTime < DOUBLE_CLICK_THRESHOLD) {
            e.preventDefault();
            if (modal) {
                if (modal.classList.contains('visible')) {
                    modal.classList.remove('visible');
                } else {
                    mouse.set((e.clientX / innerWidth) * 2 - 1, -(e.clientY / innerHeight) * 2 + 1);
                    raycaster.setFromCamera(mouse, camera);
                    const hit = raycaster.intersectObjects(group.children.filter(o => o.isMesh && o.userData && o.userData.url));
                    if (hit.length) {
                        if (modalImg) modalImg.src = hit[0].object.userData.url;
                        modal.classList.add('visible');
                    }
                }
            }
        }
        lastClickTime = currentTime;
    });

    window.addEventListener('resize', () => {
      camera.aspect = innerWidth / innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });

    // Initial setup
    initializeHudValues(); // Set HUD elements to reflect initial/URL param values
    buildScene();
    setupHUDListeners(); // Setup listeners after initial values are set
    animate();

  </script>
</body>
</html>
